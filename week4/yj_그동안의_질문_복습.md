<body><article id="0d93f289-2844-45a7-a1fb-171d972337ef" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">🕤</span></div><h1 class="page-title">그동안의 질문 복습</h1></header><div class="page-body"><p id="d1865dbe-f265-4ad3-a3c5-0212b7fbfd9e" class="">
</p><h1 id="095e5643-5b2c-4192-abdf-213416239dd1" class="">3장</h1><h2 id="6465460f-9e5f-428d-8893-ca48e3faad7c" class="">Q1. 시스템 콜을 설명하세요</h2><ul id="5f7505bb-6ca4-4b79-bd73-0123825eb3bc" class="bulleted-list"><li style="list-style-type:disc">커널에서 익셉션을 처리하는 작업 중 하나를 말함</li></ul><ul id="0c3f8c0d-21b0-4a3a-b738-9481d471a59c" class="bulleted-list"><li style="list-style-type:disc">시스템 콜은 프로그램의 거의 모든 코드의 실행에서 발생하며 파일 생성이나 쓰기 또는 읽기, 키보드 입력, 그래픽 출력, 스레드 생성 및 제어 같은 것도 시스템 콜을 통해 커널에 요청하여 커널 모드에서 처리함</li></ul><ul id="596144b1-df97-44bf-89e3-1d3cfeae2946" class="bulleted-list"><li style="list-style-type:disc">사용자 모드에 있는 프로그램이 시스템 함수를 직접 호출할 수 없으므로 따로 프로그램이 커널 호출을 요청하는 시스템을 만들어서 커널이 처리해야할 일을 프로그램으로부터 받아서 처리하는 것</li></ul><ul id="813482a7-6586-4f7c-bc58-a8bfec79f49d" class="bulleted-list"><li style="list-style-type:disc">사용자 모드에서 커널 모드로 들어가는 방법은 <strong>INT</strong>나 <strong>SYSENTER </strong>명령어를 이용<ul id="1a4aee91-641f-4da7-bd1c-a8a79916f690" class="bulleted-list"><li style="list-style-type:circle">커널 모드에 들어가면 시스템 콜 테이블에서 요청한 함수의 주소를 가져와서 실제 함수를 호출하고 <strong>IRETD</strong>(INT 2E를 사용할 경우) 또는 <strong>SYSEXIT</strong>(SYSENTER를 사용할 경우) 명령어를 통해 사용자 모드로 복귀하게 된다</li></ul></li></ul><ul id="abff97fa-629c-4fc7-8dee-581936933a1a" class="bulleted-list"><li style="list-style-type:disc"><pre id="624809cd-c0c4-44d6-827f-e70ff86bf5dc" class="code code-wrap"><code>우리가 일반적으로 사용하는 프로그램은 &#x27;응용프로그램&#x27;입니다. 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기 때문에, 커널(kernel)의 도움을 반드시 받아야 합니다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드에서는 수행할 수 없습니다. 반드시kernel에 관련된 것은 커널모드로 전환한 후에야, 해당 작업을 수행할 권한이 생깁니다. 커널 모드를 통한 이러한 작업은 반드시시스템 콜을 통해 수행하도록 설계되어 있습니다.</code></pre><p id="dd90bc6d-fb38-4cc8-ad2e-5601a2f34535" class="">출처: <a href="https://fjvbn2003.tistory.com/306">https://fjvbn2003.tistory.com/306</a></p></li></ul><h2 id="b69ef505-1618-4ffb-bd66-9040c29a6b22" class="">Q2. 프로세스와 스레드를 설명하세요.</h2><ul id="67662b6e-0821-4aa5-92b6-c9311721eabd" class="bulleted-list"><li style="list-style-type:disc">프로세스<ul id="4a3f80b6-87fe-432e-a56f-41fa5f39004b" class="bulleted-list"><li style="list-style-type:circle">• 프로세스는 os에 의해 메모리와 CPU를 할당받은 작업의 단위이다.</li></ul></li></ul><ul id="efd4a7fd-ee8d-4145-a69c-5a1d232bf40c" class="bulleted-list"><li style="list-style-type:disc">스레드<ul id="51f9d5e1-dbb9-4d4c-a022-032ca7b38058" class="bulleted-list"><li style="list-style-type:circle">• 스레드는 프로세스 내에 포함되어, 자원을 이용하는 실행단위</li></ul></li></ul><h2 id="b7db5e21-3532-44a3-8330-4a4d02e4205e" class="">Q3. 멀티스레딩이란?</h2><ul id="5f591a0b-e3d9-476c-98bf-2383c4711154" class="bulleted-list"><li style="list-style-type:disc">하나의 프로세스 내의 여러 스레드를 사용</li></ul><ul id="8bdeee28-e7e9-4e7a-9673-3def7442c60e" class="bulleted-list"><li style="list-style-type:disc">자원을 효율적으로 사용 가능</li></ul><h2 id="a039f0e0-0527-41c5-9d58-1435adfc8c44" class="">Q3. <strong><strong>Name resolution의 과정을 설명하세요.</strong></strong></h2><ul id="1586dd4e-7549-4579-8790-98d958114e01" class="bulleted-list"><li style="list-style-type:disc">name resolution은 주어진 url(이름)에 대한 ip를 알아내는 과정을 의미</li></ul><ol type="1" id="99d1741e-c628-43bc-821b-8a7c4356bef8" class="numbered-list" start="1"><li>localhost에서 name 을 검색</li></ol><ol type="1" id="67338d41-9bf4-4636-a47e-8f47fdf92c40" class="numbered-list" start="2"><li>못 찾은 경우, Host 파일에서 name 검색</li></ol><ol type="1" id="43777a37-ea89-4f68-9747-7446211436d3" class="numbered-list" start="3"><li>또 못찾으면, DNS에서 name rjator<ol type="a" id="ebca89bf-35f3-4d27-ae40-a8e9475aa254" class="numbered-list" start="1"><li>리눅스의 경우 /etc/hosts 파일을 먼저 검색</li></ol><ol type="a" id="5b7ced95-e4fe-45cf-b94d-2cf30e1014f6" class="numbered-list" start="2"><li>해당 파일에도 정보가 없다면 /etc/resolv.conf 파일을 탐색하여 <strong>네임서버로 요청</strong>을 보낸다</li></ol></li></ol><ol type="1" id="4d8f1a8d-530e-48f7-ab48-3c95caf3608a" class="numbered-list" start="4"><li>네임 서버에도 없다면 외부 DNS를 탐색한다.</li></ol><h2 id="d4a41e77-7800-40e0-87ed-31ffe42708f9" class="">Q4. 도커와 가상 머신 비교</h2><ul id="c479797f-8910-4274-81d5-54c905253e8d" class="bulleted-list"><li style="list-style-type:disc"><a href="https://hoon93.tistory.com/41">https://hoon93.tistory.com/41</a></li></ul><ul id="d9674ae4-5b82-4765-bfea-b91a5e8dbacd" class="bulleted-list"><li style="list-style-type:disc">컨테이너와 가상머신 공통점<ul id="6fc26c65-5b81-4fd5-adae-6325482bb9a7" class="bulleted-list"><li style="list-style-type:circle">리소스 분리 및 할당한다는 장점을 가지고 있음</li></ul></li></ul><ul id="48237635-1ad8-49bf-829c-26b016bb694d" class="bulleted-list"><li style="list-style-type:disc">컨테이너는 OS를 가상화 함<ul id="0f68ef9f-4ce7-403a-b3df-64d1fe96fadc" class="bulleted-list"><li style="list-style-type:circle">컨테이너는 호스트 OS와 OS 커널을 공유하므로 컨테이너 실행이나 정지 속도 빠름</li></ul><ul id="991201b3-1fb0-4806-9738-849826bf8510" class="bulleted-list"><li style="list-style-type:circle">호스트 OS 커널만 공유 : VM만 사용하는 경우와 비교해서 한대의 호스트 머신상에서 훨씬 많은 컨테이너 사용 가능. 리소스를 한데 묶어서 쉽게 관리 가능</li></ul></li></ul><h2 id="a6ed8c2c-a4c1-41c5-bd16-8f63857309b6" class="">Q5. CDN이 무엇인지 설명하세요.</h2><ul id="27afb2a4-90b5-4f8e-8268-08511a37b03f" class="bulleted-list"><li style="list-style-type:disc">Content Delivery Network</li></ul><ul id="eb346cfc-b308-484a-ba4c-fe58d029b596" class="bulleted-list"><li style="list-style-type:disc">데이터 사용량이 많은 애플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크.</li></ul><ul id="80e358f6-e8f8-4ffd-9640-c349a1e22066" class="bulleted-list"><li style="list-style-type:disc">목적 : 대기 시간을 줄이거나 네트워크 설계로 인해 발생하는 통신 지연을 줄이는 것</li></ul><ul id="b1cf9acf-a89f-4128-89db-d1d69871bf7f" class="bulleted-list"><li style="list-style-type:disc">대량의 데이터 전송에 특화 된 것으로 전세계에 있는 데이터 복사본(캐시)를 배치하는 기술과 병렬 기술을 활용해서 처리를 조율화 하고 있음</li></ul><ul id="e2455cbd-5afa-4426-832a-1eb4c62ac833" class="bulleted-list"><li style="list-style-type:disc">단점<ul id="09336ad6-b027-46c8-8559-05b6dee2f3b3" class="bulleted-list"><li style="list-style-type:circle">하나의 시스템에 대한 사용자수가 제한되어 있음</li></ul><ul id="5d4b6f09-1baa-4ab7-9f56-e4d9bc043dc8" class="bulleted-list"><li style="list-style-type:circle">참조뿐만 아니라 데이터를 갱신하는 업무가 많음</li></ul></li></ul><h1 id="e543ddaa-147c-4af4-847a-759067e0a96d" class="">4장</h1><h2 id="5b825ba7-2c34-457d-802c-47b7ab03e627" class="">Q1. <strong><strong>동시성과 병렬성에 대해 설명하세요.</strong></strong></h2><ul id="8e7015d4-cc4d-4314-b534-ef1285a9a268" class="bulleted-list"><li style="list-style-type:disc">동시성<ul id="0d1245b1-4473-4c9b-b465-8cf2d12b9006" class="bulleted-list"><li style="list-style-type:circle"><strong>프로세서 하나</strong>가 이것 조금 저것 조금해서 여러 작업을 돌아가면서 일부분씩 진행하여 마치 동시에 진행되고 있는 것처럼 보이는 것</li></ul><ul id="e879388a-4cef-48f1-be16-3e6918799a46" class="bulleted-list"><li style="list-style-type:circle">컨텍스트 스위칭</li></ul></li></ul><ul id="471ba055-f693-4eb9-bbfc-85dee8979262" class="bulleted-list"><li style="list-style-type:disc">병렬성<ul id="a47e8653-9a6e-458e-8c9c-fcea296177fc" class="bulleted-list"><li style="list-style-type:circle"><strong>프로세서 하나</strong>에 <strong>코어 여러개</strong> 달려서 각각 동시에 작업 수행하는 것</li></ul><ul id="6b1bfa2f-1c45-4a6e-91a0-20cd8b38a947" class="bulleted-list"><li style="list-style-type:circle">CPU나 스레드를 여러개 이용해서 병렬적으로 처리 하는 것</li></ul><ul id="0351e090-b284-4315-a3c4-5deb3fbc3de1" class="bulleted-list"><li style="list-style-type:circle">듀얼코어 쿼드코어 옥타코어</li></ul></li></ul><h2 id="07a043eb-2fa1-4ee3-a904-dd2a3003ffa5" class="">Q2. 가변길이와 고정길이를 설명하세요</h2><ul id="7df4c198-c15e-4140-9143-aa53750e4d09" class="bulleted-list"><li style="list-style-type:disc">세그먼트<ul id="41c863d9-78a3-41e8-95c1-a45b0bce5b4e" class="bulleted-list"><li style="list-style-type:circle">가변길이<ul id="d6476586-6376-4649-807d-59dc6e93fcbd" class="bulleted-list"><li style="list-style-type:square">장 : 공간 활용 자유도 높음</li></ul><ul id="f408063f-8af8-4c5d-adcd-0631631b7c98" class="bulleted-list"><li style="list-style-type:square">단 : 데이터 편중 높음, 탐색에 오랜시간 걸림</li></ul><ul id="e0317c93-48b0-4176-abe0-fc764a27c2f4" class="bulleted-list"><li style="list-style-type:square">외부 단편화 - <strong>tcp/ip 패킷 처리</strong></li></ul></li></ul><ul id="f41ab6cb-31e9-48e6-abb3-69ea981d0984" class="bulleted-list"><li style="list-style-type:circle">가변 길이 전송 방식<ul id="8afd79c8-1d0f-4db7-90b6-2a935d08a308" class="bulleted-list"><li style="list-style-type:square">사이즈가 얼마나 오고 갈지 모를 때에 사용</li></ul></li></ul></li></ul><ul id="2a3b9d0d-cab2-4880-b01c-0fab5325c224" class="bulleted-list"><li style="list-style-type:disc">페이징<ul id="ff04d836-72ac-40f0-8a64-59e84041cfae" class="bulleted-list"><li style="list-style-type:circle">고정길이<ul id="2a9dd247-c350-44c0-9dd6-8bbb59ec480b" class="bulleted-list"><li style="list-style-type:square">장 : 탐색과 성능에서 안정적</li></ul><ul id="d785e7d5-b24b-49ad-b314-a550c454d934" class="bulleted-list"><li style="list-style-type:square">단 : 남는공간 발생 높음</li></ul><ul id="fdcdd6c7-41d8-4883-95f2-441afda11475" class="bulleted-list"><li style="list-style-type:square">내부 단편화 - 디스크의 파일 저장</li></ul></li></ul><ul id="5e595a20-6ac8-4030-81b9-0bb68b685074" class="bulleted-list"><li style="list-style-type:circle">고정 길이 전송 방식<ul id="19f3db88-fd91-470c-8db6-fb25966937eb" class="bulleted-list"><li style="list-style-type:square">동일한 길이의 데이터를 날리고 동일한 데이터의 길이를 받는 전송 방식을 말함<ul id="3f346575-a76f-42ac-8569-3abe56c283d5" class="bulleted-list"><li style="list-style-type:disc">예를 들어서 512바이트를 전송하게 되면, 이 바이트를 넘지 않아야된다는 것</li></ul></li></ul></li></ul></li></ul><ul id="1c3846bf-db52-438a-af7f-46ff82897b83" class="bulleted-list"><li style="list-style-type:disc">단편화 연결</li></ul><ul id="f58dedd3-34f4-4637-bddd-d3bf4adf76ff" class="bulleted-list"><li style="list-style-type:disc">사용 되는 곳<ul id="fd2d46b4-bcc8-4882-874b-24df2c79c0d3" class="bulleted-list"><li style="list-style-type:circle">파일시스템<ul id="d9cf49b6-31fe-4d40-98a4-906d771bda96" class="bulleted-list"><li style="list-style-type:square">윈도우에 NTFS - 고정길이</li></ul></li></ul><ul id="a0b10140-3ce5-497f-8d2f-96bd85e8f955" class="bulleted-list"><li style="list-style-type:circle">네트워크<ul id="fdd145c2-9e93-4f7a-b461-4404d0d38fa6" class="bulleted-list"><li style="list-style-type:square">데이터 전송시 가변/고정 결정함</li></ul><p id="0f964df4-4d63-4b44-9443-50cff8648226" class="">
</p></li></ul></li></ul><h2 id="f4afd33b-f8e6-405f-8652-831751695845" class="">Q3. 교착상태에 대한 설명과 교착상태가 일어나기 위한 조건은?</h2><ul id="3ce26a83-d92a-4eea-9252-12335e6023fd" class="bulleted-list"><li style="list-style-type:disc">교착상태는 운영체제가 프로세스를 작동시킬수 없는 상태로, 일어나기위한 4가지 조건이 있음</li></ul><ol type="1" id="0df1e90a-c340-47e0-90b4-a44caf7469b0" class="numbered-list" start="1"><li>상호배제<ol type="a" id="11ee451d-1d5c-4bfd-9bb8-47ede458b381" class="numbered-list" start="1"><li>프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구</li></ol></li></ol><ol type="1" id="27ced8be-f591-4fc0-aef4-c024114a8e6b" class="numbered-list" start="2"><li>점유대기 (한정대기)<ol type="a" id="a9374fd8-93e0-4832-9405-ae15a9138d58" class="numbered-list" start="1"><li>프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.</li></ol></li></ol><ol type="1" id="af300c18-8c44-4ebf-abe1-42f23ac565da" class="numbered-list" start="3"><li>비선점<ol type="a" id="680524ad-5813-4b61-81f0-9ae14cd50376" class="numbered-list" start="1"><li>프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.</li></ol></li></ol><ol type="1" id="67732e4d-dbc8-4514-aa41-215a275927e3" class="numbered-list" start="4"><li>순환 대기<ol type="a" id="43b47c41-976a-44b7-88dc-8f9cd2374334" class="numbered-list" start="1"><li>각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.</li></ol></li></ol><h2 id="d3e2707f-04bf-47c3-971e-580658fb48c9" class="">Q4.  배타적 제어에 대해 설명하세요</h2><ul id="cd1f029e-0868-46cc-8599-dc10665d77ed" class="bulleted-list"><li style="list-style-type:disc">배타적 제어는 한번 데이터접근에 하나의 프로세스만 접근할 수 있도록 하는 것으로 병렬 처리와 같은 여러개의 작업이 데이터를 공유할 때 필요합니다.</li></ul><ul id="69c249b2-ef4a-41a3-befe-a053c4da160f" class="bulleted-list"><li style="list-style-type:disc">공유데이터의 일관성을 유지할수 있으나 병렬처리가 되지않습니다. 필요한 곳에만 배타적 제어를 적용해 cpu 활용도를 높여야합니다.</li></ul><ul id="d0159b0d-570c-4313-aabc-3a37162de1f3" class="bulleted-list"><li style="list-style-type:disc">한 프로세스가 점유하고 있는 자원에 대해서, 다른 프로세스가 사용할 수 없도록 하는 것을 의미한다.</li></ul><ul id="7f5175d8-66ee-4cba-95d0-7dac73f6bbcd" class="bulleted-list"><li style="list-style-type:disc">특징<ul id="4afd9687-ed5b-456c-9eda-39a7ffa7f5a4" class="bulleted-list"><li style="list-style-type:circle">복수의 처리가 공유자원에 동시에 접근시에 정보의 불일치가 발생할 수 있다.</li></ul><ul id="ad68a5b7-206c-4166-a4e8-647746a47111" class="bulleted-list"><li style="list-style-type:circle">공유자원을 이용하고 있는 동안에는, 다른 곳에서 자원 이용을 할 수 없도록 해야한다.</li></ul></li></ul><h2 id="88942ed9-3134-44ad-9733-779b2fd29057" class="">Q5. 세마포어란?</h2><ul id="b6dff687-94aa-4bfd-9c0f-6e09bcabb81b" class="bulleted-list"><li style="list-style-type:disc">세마포어란, 일반화된 뮤텍스입니다.</li></ul><ul id="bfd5b485-3b5f-463c-aa25-c11e4829a430" class="bulleted-list"><li style="list-style-type:disc">뮤텍스로 세마포어를 구현 가능하며, 세마포어로 뮤텍스를 구현할 수도 있습니다.</li></ul><ul id="5824ee89-f65d-4050-9854-33c924b3f976" class="bulleted-list"><li style="list-style-type:disc">간단한 정수 값과 두 가지 함수(WAIT과 SIGNAL)로 공유자원에 대한 접근을 처리합니다.</li></ul><h2 id="87936c07-d473-46ec-b772-604a70ae31af" class="">Q6. 프로세스 상태에 대해 설명</h2><ul id="b2a4ec7f-f6fd-4556-8897-637036d8377b" class="bulleted-list"><li style="list-style-type:disc">5가지로 분류</li></ul><ul id="9f0112e3-11e3-4320-a527-24d83f17f23d" class="bulleted-list"><li style="list-style-type:disc">생성<ul id="976ab057-86b7-46af-849d-5ad46046abdd" class="bulleted-list"><li style="list-style-type:circle">생성은 프로세스 실행이 개시되는 과정입니다.</li></ul><ul id="e328169e-a079-4a28-ad00-14acc4526654" class="bulleted-list"><li style="list-style-type:circle">주기억 장치가 아닌 보조기억 장치에 적재되어있는 실행파일 상태</li></ul></li></ul><ul id="5e776bd8-7671-4526-a662-b9f741e6b131" class="bulleted-list"><li style="list-style-type:disc">준비<ul id="c5a73fe4-1ab1-44a6-ba4d-f96583da34c5" class="bulleted-list"><li style="list-style-type:circle">프로세스가 CPU를 사용하여 실행 준비가 된다면, 실행 큐에서 실행대기를 하는 상태가 됩니다.</li></ul></li></ul><ul id="0fbb9001-473b-420f-8285-8ad11fe056a0" class="bulleted-list"><li style="list-style-type:disc">실행<ul id="c5fac75c-1686-4fa6-953e-6477ef3323a8" class="bulleted-list"><li style="list-style-type:circle">실제로 프로세스가 cpu를 차지하여 실행중인 상태</li></ul></li></ul><ul id="3c390046-15c5-4b28-9b8f-387d1a7c0e2e" class="bulleted-list"><li style="list-style-type:disc">대기<ul id="f18d7e97-125f-4c22-babe-04cd8f5d6830" class="bulleted-list"><li style="list-style-type:circle">I/O 동작의 완료 등의 사건 발생을 기다리는 상태</li></ul></li></ul><ul id="45fb0c66-653e-4afc-bc65-b99312761de4" class="bulleted-list"><li style="list-style-type:disc">종료<ul id="2bfaba17-19a2-4e83-9a2d-1560480ab0f4" class="bulleted-list"><li style="list-style-type:circle">프로세스 실행이 완료되어, 자원을 반납한 상태</li></ul></li></ul><h1 id="b91c8ae4-c2f2-4043-810d-bfba9d879081" class="">5장</h1><h2 id="dbfc1735-98c1-49b4-bbe1-dfdde7586b23" class="">Q1. 롤백과 롤 포워드에 대해 설명하세요</h2><ul id="eeb35096-88f9-4e98-94c0-86a3986587e7" class="bulleted-list"><li style="list-style-type:disc">롤백<ul id="31984480-467d-424d-b771-a6c0372fe752" class="bulleted-list"><li style="list-style-type:circle">저널을 읽어서 실제 데이터 정보를 과거로 되돌리는 처리</li></ul></li></ul><ul id="a9cdb483-1e88-4e07-9b22-1ea9f1f4a502" class="bulleted-list"><li style="list-style-type:disc">롤 포워드<ul id="1df725cf-a455-4e89-9fb2-c42c3bf6cab9" class="bulleted-list"><li style="list-style-type:circle">저널을 읽어서 실제 데이터 정보를 앞으로 진행시키는 처리</li></ul><ul id="1edbba43-6505-4b0c-80bb-5268b8be94f6" class="bulleted-list"><li style="list-style-type:circle">트랜잭션 단위로 실행</li></ul></li></ul><h1 id="556cc678-8394-44cf-86a4-c161f58fc593" class="">6장</h1><h2 id="f0001048-467a-4d80-a2fb-9af473eef5f4" class=""><strong>Q1. OSI 7계층과 HTTP 계층에 대해 설명해주세요</strong></h2><ul id="bc084f9c-70d0-48c7-945d-7642bd0cd7f5" class="bulleted-list"><li style="list-style-type:disc">OSI 7 계층<ul id="3eacd219-24a5-446e-9e9a-95572612754f" class="bulleted-list"><li style="list-style-type:circle">어플리케이션 계층</li></ul><ul id="e94f59bd-42b7-4a99-a4ac-ab72b9fa4094" class="bulleted-list"><li style="list-style-type:circle">프리젠테이션 계층</li></ul><ul id="ada00691-bf1b-468c-aa47-f138b4779c3f" class="bulleted-list"><li style="list-style-type:circle">세션 계층</li></ul><ul id="4178f7b1-69b1-429b-8cb0-adfd871658a4" class="bulleted-list"><li style="list-style-type:circle">전송 계층</li></ul><ul id="59c53e61-603b-4d71-884f-025c21159abf" class="bulleted-list"><li style="list-style-type:circle">네트워크 계층</li></ul><ul id="6b53d2a6-899d-4cdd-baca-239878a1a72f" class="bulleted-list"><li style="list-style-type:circle">데이터 링크 계층</li></ul><ul id="cceacedd-a002-4f1f-83c7-bfa291331946" class="bulleted-list"><li style="list-style-type:circle">물리 계층</li></ul></li></ul><ul id="61665303-8d27-4b14-aad6-9bb68232e98f" class="bulleted-list"><li style="list-style-type:disc">HTTP 계층<ul id="dd8564a2-c847-4ecf-b142-975ff7fba588" class="bulleted-list"><li style="list-style-type:circle">어플리케이션 계층(L7)</li></ul><ul id="ca60f2b6-39c7-418e-a8a4-552419931c23" class="bulleted-list"><li style="list-style-type:circle">전송 계층(L4)</li></ul><ul id="87fe0164-e996-413b-a3fa-15de9428d258" class="bulleted-list"><li style="list-style-type:circle">ip 계층(L3)</li></ul><ul id="d211b7b2-8c05-4c55-ae6c-9e17d2c9d769" class="bulleted-list"><li style="list-style-type:circle">링크 계층/이더넷 계층(L2)</li></ul></li></ul><h2 id="7e5fd460-5046-457c-9fab-45086c37ee50" class="">Q1. TCP의 역할과 기능</h2><ul id="eff31a75-8d83-4872-a0d2-c60c2dd3830a" class="bulleted-list"><li style="list-style-type:disc">TCP의 역할은, 어플리케이션이 보낸 데이터를 그 형태 그대로 상대방에게 그대로 전달하는 것</li></ul><ul id="ecde364f-306f-44fe-9731-607c65c05d16" class="bulleted-list"><li style="list-style-type:disc">TCP가 담당하는 것은 어디까지나 서버가 송신할 때와, 서버가 수신한 후 어플리케이션에게 전달할 때이다.<ul id="71cedcfa-a1db-474c-8c28-a48266e8a9ca" class="bulleted-list"><li style="list-style-type:circle">상대 서버까지 전송하는 부분은 하위 계층인 IP 계층에 모두 위임</li></ul></li></ul><ul id="3e1f2cfa-0a1f-46ba-b13e-b9ae47603fb8" class="bulleted-list"><li style="list-style-type:disc">tcp의 기능에는<ul id="f249bad0-e0ec-40a9-8101-f32ec01173db" class="bulleted-list"><li style="list-style-type:circle">포트 번호로 데이터를 전송</li></ul><ul id="c539aa1d-0dba-4eca-ae8f-dec1781d916a" class="bulleted-list"><li style="list-style-type:circle">연결을 생성</li></ul><ul id="bbc4aa14-925d-49c7-81b7-8eb3981ad9c7" class="bulleted-list"><li style="list-style-type:circle">데이터 보증, 재전송 제어</li></ul><ul id="a846f835-f653-4b3d-a4e3-0132059d8490" class="bulleted-list"><li style="list-style-type:circle">흐름 제어, 폭주 제어</li></ul></li></ul><h2 id="9be5051c-84c2-4e9b-a318-d79f8a6f7edb" class="">Q2.TCP의 흐름제어와 폭주 제어 설명</h2><ul id="d4ed7b32-09e6-4e11-b65a-1802e9ab7214" class="bulleted-list"><li style="list-style-type:disc">TCP 통신은 비동기적으로 동작 → 동기적으로 하면 느릴수가 있음 (응답 기다려야해서)<ul id="a2980dd6-389d-4880-b1af-e3c35c759cce" class="bulleted-list"><li style="list-style-type:circle">TCP는 어느 정도의 세그먼트 수라면 ACK를 기다리지 않고 전송하는 윈도우 개념</li></ul></li></ul><ul id="bce2724f-eed9-463f-958e-841dbe7c4444" class="bulleted-list"><li style="list-style-type:disc">흐름 제어<ul id="6caee4af-ec3c-4746-a27a-89e8f5e9ab45" class="bulleted-list"><li style="list-style-type:circle">기본 적으로는 수신 측이 윈도우 크기를 조정한다.<ul id="bbdb0b83-ea00-4b59-8fba-198ab2e01c28" class="bulleted-list"><li style="list-style-type:square">수신과 송신 중 작은 쪽을 송신 윈도우로 채택한다.</li></ul><ul id="0bd7629a-e150-464d-a955-46bd912dd4c3" class="bulleted-list"><li style="list-style-type:square">이 범위 내에서 ACK를 기다리지 않고 전송한다.</li></ul></li></ul><ul id="f094ac4d-c232-4d55-8eea-1afd5542e7b5" class="bulleted-list"><li style="list-style-type:circle">수신 측은 수신용 소켓 버퍼가 넘쳐서, 더 이상 수신이 불가능하게되면 수신 윈도우 크기를 작게 만들고 이 사실을 송신 측에 알린다.</li></ul></li></ul><ul id="3be79215-cf04-4bf9-88b1-3e5a71f71946" class="bulleted-list"><li style="list-style-type:disc">폭주 제어<ul id="a6b62b5d-8e30-4c31-aa2d-66147dea9059" class="bulleted-list"><li style="list-style-type:circle">네트워크 혼잡 시, 폭주 윈도우 크기를 작게하여 전송 데이터 양을 줄인다.</li></ul><ul id="76a700c8-d794-46c9-9428-9e2b7c4254d6" class="bulleted-list"><li style="list-style-type:circle">슬로우 스타트란?<ul id="67abc7b5-25d7-47f8-bc79-edf3dc9f258f" class="bulleted-list"><li style="list-style-type:square">통신 시작시 1세그먼트에 설정</li></ul><ul id="5d915356-62db-4402-b358-5d6c225f6699" class="bulleted-list"><li style="list-style-type:square">ACK 반환 시마다 폭주 윈도우의 크기를 2배씩 지수함수로 늘려나감</li></ul></li></ul></li></ul></div></article></body></html>
