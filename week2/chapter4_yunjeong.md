<body><article id="2b464551-c9ae-4642-b651-e4ddfb2c405e" class="page sans"><header><h1 class="page-title">4. 인프라를 지탱하는 기본 이론(1)</h1></header><div class="page-body"><h1 id="75d65159-81e3-457b-aac8-49c4d773af7e" class="">4. 1 직렬 / 병렬</h1><hr id="7ee4c27b-0e09-44b1-9ba4-821c438b5b1a"/><ul id="d3da127a-480b-43f0-be3a-b2d7a83b01ac" class="bulleted-list"><li style="list-style-type:disc">병렬 : 처리의 효율을 위해 CPU나 스레드를 여러개 이용해서 병렬적으로 처리하는 방법</li></ul><ul id="18b0487f-b36d-4a9c-a584-21ba5ca24712" class="bulleted-list"><li style="list-style-type:disc">CPU 코어나 서버를 병렬화 할때는 어떻게 효율적으로 활용하는지가 중요.</li></ul><ul id="2e2b0ad9-e92a-49e6-af8c-21ab69a5c40e" class="bulleted-list"><li style="list-style-type:disc">예시 ) 직렬 - 1차선 도로, 병렬 - 2차선 도로</li></ul><h2 id="2f80f48d-f99f-4e31-8e7a-89f60747dee2" class="">활용</h2><ul id="5959e96b-adfc-4ccf-9745-1f4c2c6b25d6" class="bulleted-list"><li style="list-style-type:disc">웹 서버와 AP 서버에서 병렬화<ul id="d3269879-2135-411e-a07d-468aa830ee1c" class="bulleted-list"><li style="list-style-type:circle">웹 서버는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리</li></ul><ul id="0d8e8aa9-662a-4713-adad-45ba9060d6c1" class="bulleted-list"><li style="list-style-type:circle">AP 서버에서는 JVM 프로세스가 하나이지만 복수의 스레드가 병렬로 처리</li></ul><ul id="17e07858-2388-4714-bcda-37f1f299163b" class="bulleted-list"><li style="list-style-type:circle">Apache HTTP server : 하이브리드 형</li></ul><ul id="afacde8c-752b-4919-9667-e568ce7fde21" class="bulleted-list"><li style="list-style-type:circle">프로세스나 스레드 수 조정할때는<strong> CPU 코어수</strong>도 함께 고려</li></ul></li></ul><h2 id="b9e14f5d-910c-465d-a6f8-578453c24cbb" class="">직렬/병렬 장단점</h2><table id="8be6a01a-93c5-4525-91ef-d96c94313b41" class="simple-table"><thead class="simple-table-header"><tr id="a6190d7a-ff0d-40a2-83d7-4247a670478d"><th id="?YZ_" class="simple-table-header-color simple-table-header"></th><th id="{NyG" class="simple-table-header-color simple-table-header" style="width:312.296875px">장점</th><th id="y|W=" class="simple-table-header-color simple-table-header" style="width:313px">단점</th></tr></thead><tbody><tr id="6d87f0df-c86f-42a7-84c4-63ea79c654a5"><th id="?YZ_" class="simple-table-header-color simple-table-header">직렬</th><td id="{NyG" class="" style="width:312.296875px">구조 간단, 구현 간단</td><td id="y|W=" class="" style="width:313px">복수의 리소스를 유용하게 이용하지 않음</td></tr><tr id="b577acb4-02f5-4e15-8a9c-99b6515fd196"><th id="?YZ_" class="simple-table-header-color simple-table-header">병렬</th><td id="{NyG" class="" style="width:312.296875px">복수의 리소스를 유용하게 이용 가능
직렬에 비해 동일 시간당 처리 할수 있는 양 증가
일부가 고장나도 처리 계속할수 있음</td><td id="y|W=" class="" style="width:313px">처리 분기나 합류를 위한 오버헤드 발생
배타적 제어등을 고려해야 하고, 구조가 복잡 → 설계나 구현 난이도 높음</td></tr></tbody></table><ul id="ef27493e-2707-4db7-aa4b-4845fcc3d841" class="bulleted-list"><li style="list-style-type:disc">병렬화<ul id="fbcc01cb-22b9-4fd7-8d70-c84b4a06679e" class="bulleted-list"><li style="list-style-type:circle">장점 : 단위 시간당 처리량 증가</li></ul><ul id="4f88b4e5-7495-4de0-9931-fc64d55cf877" class="bulleted-list"><li style="list-style-type:circle">단점 : 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉬움</li></ul></li></ul><ul id="8b3a3cb3-f4cc-49b5-8573-4b57b572aaa7" class="bulleted-list"><li style="list-style-type:disc">이러한 단점 이상의 효과를 얻을수 있는 경우 병렬화 해야함</li></ul><h2 id="5991d7b6-0638-4a2a-b656-cf13ecb4c352" class="">이중화</h2><ul id="637e6a7c-835b-4db8-a70a-44bdab97de3f" class="bulleted-list"><li style="list-style-type:disc">본딩 : NIC 하나로 묶어서 사용</li></ul><hr id="16e9d27e-dc06-4955-828f-6316399bf0f1"/><p id="9d30b6b8-1393-4b1f-93c8-a9efa841b686" class="">
</p><h2 id="e3e42e7d-66eb-4c5c-8e70-b7f7ae82ee70" class="">동시성/병렬성 정리</h2><div id="24b456d3-2007-49b4-b384-a6541acbf6fa" class="column-list"><div id="0a02f2c5-dbdc-4576-acbc-9194488a3cbc" style="width:50%" class="column"><h3 id="eb95cf06-5fcf-4f0f-86ed-42d352bd992d" class="">동시성</h3><ul id="f1059366-35e2-4830-a5b2-40b61e7786b0" class="bulleted-list"><li style="list-style-type:disc">프로세서 하나가 이것 조금 저것 조금해서 여러 작업을 돌아가면서 일부분씩 진행</li></ul><ul id="9100c981-be27-4d2d-be10-5f169dc7bac6" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background">마치 동시에 돌아가는거 같은 효과</mark></li></ul><ul id="8d427772-5a3c-46ac-ad7f-0164d996c5f2" class="bulleted-list"><li style="list-style-type:disc">이렇게 진행 중인 작업을 바꾸는건 
<strong>context swithcing </strong>이라고 함</li></ul><p id="a28ce815-3441-4754-89be-8789e0be7412" class="">
</p></div><div id="cab1d440-19a0-487f-9e01-a14d0e9ec21b" style="width:50%" class="column"><figure id="230173f9-bb73-4170-8703-76adda065fee" class="image"><a href="4%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%B3%E1%84%85%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%B5%E1%84%90%E1%85%A2%E1%86%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB(1)%20230173f9bb734170870376adda065fee/Untitled.png"><img style="width:339px" src="untitled.png"/></a></figure></div></div><div id="ac4b1b68-c647-42b9-a292-2ca8a67ace8a" class="column-list"><div id="38a67926-7ae1-4064-814a-a6870ee3d372" style="width:50%" class="column"><h3 id="f03ee836-b5f0-414f-89fd-2f9f210add35" class="">병렬성</h3><ul id="4c763856-789f-456f-83ec-db219ef92cae" class="bulleted-list"><li style="list-style-type:disc">프로세서 하나에 코어 여러개 달려서 각각 동시에 작업 수행</li></ul><ul id="b9b427cf-0128-4f7a-967c-fb0a92a93671" class="bulleted-list"><li style="list-style-type:disc">스레드 여러개</li></ul><ul id="c99040f1-cac0-46d7-b802-22bc9049b271" class="bulleted-list"><li style="list-style-type:disc">듀얼코어 쿼드코어 옥타코어가 이 예시</li></ul><p id="c06994a8-1bbc-404c-bf43-b1735ca02449" class="">
</p></div><div id="0e3e46e6-70ed-4828-a14d-974f8bc0d368" style="width:50%" class="column"><figure id="506cb58f-37ff-4c8c-be0a-3666bd6b7669" class="image"><a href="4%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%B3%E1%84%85%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%B5%E1%84%90%E1%85%A2%E1%86%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB(1)%20230173f9bb734170870376adda065fee/Untitled%201.png"><img style="width:346px" src="Untitled%201.png"/></a></figure></div></div><p id="291ec23c-258b-47f4-b634-7fb59976837c" class="">
</p><p id="62c5660b-f5f5-4574-9670-81646866395c" class=""><strong>직렬성 (Serializability)과 동시성 (Concurrency)</strong></p><ul id="3acc81c4-5d51-4634-8cd8-9a0ad5bdfcbd" class="bulleted-list"><li style="list-style-type:disc">데이터베이스에서 <strong>직렬성 (serializability)</strong>은 각각의 transaction이 <mark class="highlight-yellow_background">일정한 순서를 가지고 순차적으로 실행</mark>되는 것을 의미한다. </li></ul><ul id="10610e8f-daa4-43ba-8d5c-906c6fa25921" class="bulleted-list"><li style="list-style-type:disc">이와 반대로 <strong>동시성 (concurrency)</strong>은 transaction들이 순차적으로 실행되는 것이 아니라, transaction을 구성하는 <mark class="highlight-yellow_background">각각의 쿼리문들이 transaction의 순서에 상관없이 동시에 실행되는 것</mark>을 의미한다.</li></ul><p id="85b3e303-55f0-4fff-b8eb-b41e7a7b7d01" class="">
</p><h1 id="6915705f-c1a7-4938-979d-067f51b0b98a" class="">4.2 동기/비동기</h1><hr id="c72a2859-f7b9-4bf3-a026-6991b14ee9e9"/><h2 id="a46b4da2-8869-4fa8-a84a-0197f95b9d0d" class="">정의</h2><ul id="cdc8cfb1-f2e0-4920-8c96-b18b66065a07" class="bulleted-list"><li style="list-style-type:disc">Ajax (Asynchronous JavaScript + XML)</li></ul><ul id="8889faae-6042-425e-9a4d-39477a47bcfb" class="bulleted-list"><li style="list-style-type:disc">동기 : 누군가에게 일을 부탁하고 끝날때까지 잠자코 기다리는 방식<ul id="0fad25e3-c49f-495b-9a14-7ef15dfe86e0" class="bulleted-list"><li style="list-style-type:circle">의뢰한것이 끝났는지 여부를 확실히 확인 가능</li></ul></li></ul><ul id="29a1e257-8025-406b-a5e3-b1949d6c46ca" class="bulleted-list"><li style="list-style-type:disc">비동기 : 끝나면 말해 해놓고 다른 일을 하는것이 비동기<ul id="5b205fca-afc9-46f2-8126-39bee1f1eee7" class="bulleted-list"><li style="list-style-type:circle">끝날 떄까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있음</li></ul><ul id="4dd0d7be-bb2b-47dc-9e73-b3a67e66e988" class="bulleted-list"><li style="list-style-type:circle">의뢰한 일이 끝났는지 확인 하고 싶으면 별도의 방법 이용 - 콜백 url</li></ul></li></ul><h2 id="157fc3f3-6134-4f84-b971-dad69e02f3f0" class="">사용</h2><h3 id="39c3acce-eebb-423f-ad6a-0e422a5dfc7f" class="">Ajex</h3><ul id="903166a6-2f6b-4400-a3a8-76bda63a6298" class="bulleted-list"><li style="list-style-type:disc">필요한 부분만 갱신<ul id="bed40070-9338-448f-8344-056b00f3d5a9" class="bulleted-list"><li style="list-style-type:circle">이전) 링크나 버튼을 클릭할 때마다 화면 전체가 바뀌는 것을 기다림</li></ul></li></ul><ul id="03294112-1188-4d76-add9-54ecf1e2521c" class="bulleted-list"><li style="list-style-type:disc">ex) 구글 검색 엔진 - 키워드 입력과 키워드 추천이 비동기로 이뤄짐 (병렬)</li></ul><h2 id="e3e49fb0-da3c-4383-99b5-831c3b2d7ede" class="">동기/비동기 장단점</h2><table id="2a1a959c-940e-45fc-a061-d50f9778e0ec" class="simple-table"><thead class="simple-table-header"><tr id="0c78e6d5-3398-4b62-9e93-679c23931e4d"><th id="Te?{" class="simple-table-header-color simple-table-header"></th><th id="LY_`" class="simple-table-header-color simple-table-header" style="width:235px">장점</th><th id="[U`d" class="simple-table-header-color simple-table-header" style="width:299px">단점</th></tr></thead><tbody><tr id="8885e4d0-267a-49d9-8f71-852355e45581"><th id="Te?{" class="simple-table-header-color simple-table-header">동기</th><td id="LY_`" class="" style="width:235px">의뢰한 처리가 끝났는지 여부 확인 가능
구조 간단, 구현 난이도 낮음</td><td id="[U`d" class="" style="width:299px">의뢰한 처리 끝날때까지 대기해야 해서 대기 시간 활용 불가</td></tr><tr id="ce5de71a-c97c-46d6-b5cd-ca71612e9451"><th id="Te?{" class="simple-table-header-color simple-table-header">비동기</th><td id="LY_`" class="" style="width:235px">의뢰한 처리가 진행되는 동안 다른 일 처리 가능(병렬 처리)</td><td id="[U`d" class="" style="width:299px">의뢰한 처리 끝났는지 확인 하지 않으면 모름 - 불필요한 확인 처리 필요
구조 복잡, 구현 난이도 어려움</td></tr></tbody></table><ul id="0b09ac2a-8087-4e61-a668-1537f435bcc0" class="bulleted-list"><li style="list-style-type:disc">주의사항<ul id="008c1797-7a7a-4e83-89a7-9b580fa930a1" class="bulleted-list"><li style="list-style-type:circle">비동기로 요구한 처리가 끝나지 않은 상태에서 다음 처리 진행해도 문제 없는가</li></ul><ul id="c726618e-0ef9-484d-926f-5074887a4990" class="bulleted-list"><li style="list-style-type:circle">비동기가 요구한 처리가 끝났는지 확인할 필요가 있는가</li></ul></li></ul><ul id="fe1a0e56-c64b-4456-a56f-351f005901a9" class="bulleted-list"><li style="list-style-type:disc">사용<ul id="665387ad-769d-45e8-a03f-a79ad5c02e70" class="bulleted-list"><li style="list-style-type:circle">DBMS 복제할때 동기, 비동기 모드 선택 가능</li></ul><ul id="467567e5-87a9-4df5-81ec-ef9be65a7c2d" class="bulleted-list"><li style="list-style-type:circle">메시지큐</li></ul></li></ul><h1 id="054de389-4248-445d-8f75-0cde0bc4e8d6" class="">4.3 큐</h1><ul id="aa312f18-e88f-465b-a4dd-3b8a9810a91d" class="bulleted-list"><li style="list-style-type:disc">대기 행렬</li></ul><h2 id="cf3eb15b-e67d-4db3-9cfa-05958b725a32" class="">사용</h2><ul id="f4facc76-b353-46ee-96d9-23ca29d129ef" class="bulleted-list"><li style="list-style-type:disc"><strong>CPU 처리를 기다리고 있는 프로세스나 스레드 행렬</strong></li></ul><ul id="ddd475b2-3748-4496-bdfa-d64fe39f4d79" class="bulleted-list"><li style="list-style-type:disc">하드 디스크 등의 <strong>저장소 읽기 처리</strong>를 기다리고 있는 I/O 요구 행렬</li></ul><ul id="eccf1112-d531-4a4c-84dc-1e32577f033c" class="bulleted-list"><li style="list-style-type:disc">네트워크 접속 성립을 기다리고 있는 접속 요구 행렬</li></ul><h3 id="2ed2053d-e76e-4d9c-83d1-a7f9633a87e6" class="">런큐</h3><ul id="a6877d75-3a04-4b63-a645-5ad1d580c265" class="bulleted-list"><li style="list-style-type:disc">CPU를 기다리고 있는 프로세스 행렬</li></ul><ul id="5334cbf8-fb5f-48c8-802b-89be59d710da" class="bulleted-list"><li style="list-style-type:disc">런큐에 쌓인 프로세스 수를 코어수로 나누어서 1이라면 상관 없다</li></ul><p id="f8108201-5112-4b4c-b02e-8100cb37dba4" class="">
</p><p id="bd555fae-d4bd-419e-9257-33dfe57c1df1" class="">** 코어 2개 - 컴퓨터의 중앙처리장치(CPU) 내에 있는 개별 처리 장치가 2개</p><p id="4ceca3b0-4fe6-433e-821e-2457b51cd32c" class="">
</p><h2 id="ab39cb38-85d9-4f62-b00d-d252a4e82201" class="">큐 정리</h2><ul id="e0973a3f-f5e3-406c-85ae-c19fa165e64f" class="bulleted-list"><li style="list-style-type:disc">순차적으로 처리</li></ul><ul id="48ca96d7-ac22-4c37-9495-d2d95ebeac3b" class="bulleted-list"><li style="list-style-type:disc">여러처리가 동시에 진행되는 경우 큐가 사용</li></ul><ul id="ee7a0283-6c1b-4f26-9e89-2b2dc149fdaa" class="bulleted-list"><li style="list-style-type:disc">순서대로 처리를 하고 싶은 경우나 행렬이 생기는 경우 사용</li></ul><ul id="5f7dc50f-da30-4fe8-bbed-9a6ab76f85f5" class="bulleted-list"><li style="list-style-type:disc">성능 문제가 발생하면?<ul id="14c8a070-c5b9-4965-9c24-c4043c26a0c2" class="bulleted-list"><li style="list-style-type:circle">큐의 길이(행렬의 길이) 확인 하는 것이 중요</li></ul><ul id="5ed9ea3e-bea5-4382-85f3-efc70af41ab3" class="bulleted-list"><li style="list-style-type:circle">CPU 사용률 뿐만 아니라 런큐 길이도 함께 확인</li></ul></li></ul><h3 id="ce91ccfa-f76f-4a1e-ba91-978fdbc5c38a" class="">메시지 큐</h3><ul id="926e7a0b-e235-471a-866c-17c388efbe34" class="bulleted-list"><li style="list-style-type:disc">애플리케이션 간 상호 운용성 향상시켜 시스템 전체 안정성 향상<ul id="e790bd74-0938-4ed9-baa3-7d311f44da67" class="bulleted-list"><li style="list-style-type:circle">어딘가 멈춘다고 해도 시스템 전체가 멈추는 것은 아님</li></ul></li></ul><ul id="5b1dc786-a6e3-4afe-a70c-98c265eef858" class="bulleted-list"><li style="list-style-type:disc">이메일</li></ul><p id="f9483e80-980e-4776-9d49-0f65c2d51c03" class="">
</p><h1 id="38e4f1de-63f6-433f-b229-d2a1b3ac04fd" class="">4. 4 배타적 제어</h1><hr id="a1636270-be2e-4b25-a595-797d0bc2cd33"/><ul id="5b16cfda-3de0-403f-9484-cdd052d0f93f" class="bulleted-list"><li style="list-style-type:disc">공유 자원을 하나가 점유 했을 때 다른 사람(- 다른 처리 : 프로세스, 스레드)이 이용 하지 못하도록 하는 것</li></ul><ul id="34c65f59-5cb3-4443-b9e7-351ae81bb2f7" class="bulleted-list"><li style="list-style-type:disc">OS &amp; DBMS 가 병렬처리를 위해 배타적 제어 사용</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="50d5c2ed-101b-4b01-a18a-f79e5ae23acd"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">- 복수의 처리가 공유 자원 (CPU, 메모리, 디스크)에 동시에 액세스 하면 불일치가 발생할수 있으므로 배타적 제어로 보호
- 특정 처리가 공유자원을 이용하고 있는 동안 다른 처리가 이용할수 없도록 해서 불일치 발생하지 않도록 함</div></figure><h2 id="eb3dc6dc-9184-4778-877a-7207d7e272b4" class="">사용</h2><ul id="952e9e12-bf1e-45dd-b687-53f2b61984df" class="bulleted-list"><li style="list-style-type:disc">DBMS<ul id="83d30730-efef-42e4-bfca-bc4a575372b8" class="bulleted-list"><li style="list-style-type:circle">래치 : <strong>매우 짧은 시간 </strong>동안만 락을 유지<ul id="d5692a00-3a1c-4506-aa24-7edc18d03a1a" class="bulleted-list"><li style="list-style-type:square">CPU에서 의미가 없는 처리를 하면서 대기하는 방식</li></ul><ul id="5f861827-b4ef-4dc7-9882-fb7ae4405948" class="bulleted-list"><li style="list-style-type:square">= 스핀락</li></ul></li></ul><ul id="5a1f8f8e-571e-4a95-ab25-9b88955fd931" class="bulleted-list"><li style="list-style-type:circle">슬립 락<ul id="f7f1996e-ec3b-4f2b-8d9b-4f39972ad7e2" class="bulleted-list"><li style="list-style-type:square">비교적 <strong>장시간 락</strong>을 유지하도록 큐 이용</li></ul><ul id="7a813355-3961-41f5-a845-17c36dfa0fb5" class="bulleted-list"><li style="list-style-type:square">CPU에서 의미 없는 처리를 반복하면서 대기</li></ul></li></ul><ul id="b9167ce5-1654-48c9-9d4a-7eb2e8722774" class="bulleted-list"><li style="list-style-type:circle"> 어댑티브 락<ul id="e82c4f8b-f167-40ce-a90e-5df4b35be44f" class="bulleted-list"><li style="list-style-type:square">스핀해서 락을 확보하지 못하면 슬립하는 등 상황에 따라 <strong>스핀할지 슬립 할지 판단</strong></li></ul></li></ul></li></ul><ul id="6e3d89b5-4bb4-48e1-85f2-cbec0a37eefa" class="bulleted-list"><li style="list-style-type:disc">OS 커널에서 사용되는 배타적 제어<ul id="874c9388-e4fe-499d-a3e4-6f3629091faa" class="bulleted-list"><li style="list-style-type:circle"><strong>BKL(빅 커널 락) : </strong>커널은 하나의 스핀락으로 유지<ul id="a2ae7f24-bb95-4884-aa99-28942c40fef6" class="bulleted-list"><li style="list-style-type:square"><strong>처리가 직렬화</strong>돼서 <strong>동시에 하나의 CPU만 커널 코드를 실행 가능</strong><ul id="0ebc3fa6-b24c-4999-a54f-180dab43f2b2" class="bulleted-list"><li style="list-style-type:disc">이 부분은 병목지점 되기 쉬움</li></ul></li></ul></li></ul></li></ul><ul id="1db789e8-982d-4d8b-a54c-bec76a46c4d5" class="bulleted-list"><li style="list-style-type:disc">클러스터 데이터 베이스의 배타적 제어</li></ul><h2 id="242acf14-b242-48f9-a508-153060db6657" class="">정리</h2><ul id="44d913cb-9617-48e4-9abb-788deb5c33f2" class="bulleted-list"><li style="list-style-type:disc">배타적 제어의 장단점<table id="7d8168dc-2302-43db-b39d-170dad43832e" class="simple-table"><thead class="simple-table-header"><tr id="ff38cc53-d0c0-414e-9162-57636534bf3d"><th id="IxPG" class="simple-table-header-color simple-table-header" style="width:139px"></th><th id="AsZd" class="simple-table-header-color simple-table-header" style="width:201.53125px">장점</th><th id="nyAM" class="simple-table-header-color simple-table-header">단점</th></tr></thead><tbody><tr id="36859280-bd22-4a03-ab8b-df7c69b6d65c"><th id="IxPG" class="simple-table-header-color simple-table-header" style="width:139px">사용</th><td id="AsZd" class="" style="width:201.53125px">공유 데이터 <strong>일관성</strong> 유지</td><td id="nyAM" class="">병렬 처리 안됨</td></tr><tr id="3d652fd7-790a-4423-bc21-27c7ce8d3683"><th id="IxPG" class="simple-table-header-color simple-table-header" style="width:139px">비사용</th><td id="AsZd" class="" style="width:201.53125px">병렬로 <strong>빠르게</strong> 처리 가능</td><td id="nyAM" class="">데이터 불일치 발생할 가능성이 있음
- 동시에 데이터 변경 하는 경우</td></tr></tbody></table></li></ul><ul id="38fa32a7-73c6-4293-8270-0137f99c87a0" class="bulleted-list"><li style="list-style-type:disc">멀티 프로세서 시스템에서는 배타적 제어가 어려움</li></ul><p id="23f94934-6c9c-4cdd-8ad0-f4dc80979256" class="">
</p></div></article></body></html>
