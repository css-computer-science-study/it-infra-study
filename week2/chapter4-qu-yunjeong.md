<body><article id="efc7db12-c156-4661-83a1-a9d69baa39f9" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">💡</span></div><h1 class="page-title">4.인프라를 지탱하는 기본 이론</h1></header><div class="page-body"><h2 id="f9c30fa3-f89e-46d0-920f-4d4132484bda" class="">Q1. 직렬과 병렬에 대해서 설명 + 동시성과 병렬성에 대해 설명하세요.</h2><ul id="b8d7861b-68b6-48bc-bb66-37519b8d3c4b" class="bulleted-list"><li style="list-style-type:disc">병렬 : 처리의 효율을 위해 CPU나 스레드를 여러개 이용해서 병렬적으로 처리하는 방법</li></ul><ul id="df872c0b-c93a-486f-91be-4011d14eed59" class="bulleted-list"><li style="list-style-type:disc">동시성<ul id="6caff03e-4f68-4ad7-94a4-4faa672aba5d" class="bulleted-list"><li style="list-style-type:circle"><strong>프로세서 하나</strong>가 이것 조금 저것 조금해서 여러 작업을 돌아가면서 일부분씩 진행하여 마치 동시에 진행되고 있는 것처럼 보이는 것</li></ul><ul id="fa612a49-ac0c-47a1-b299-b51a007b63bb" class="bulleted-list"><li style="list-style-type:circle">컨텍스트 스위칭</li></ul></li></ul><ul id="300a50f5-227b-482f-adc6-a23291469d8e" class="bulleted-list"><li style="list-style-type:disc">병렬성<ul id="98ce4190-643b-4ae6-acc4-37519aaf8817" class="bulleted-list"><li style="list-style-type:circle">프로세서 하나에 코어 여러개 달려서 각각 동시에 작업 수행하는 것</li></ul><ul id="813c0aa8-41c5-4bd4-9b90-8b4b75154c3a" class="bulleted-list"><li style="list-style-type:circle">CPU나 스레드를 여러개 이용해서 병렬적으로 처리 하는 것</li></ul><ul id="37766c10-3dbb-44d2-a856-9a9354ff6576" class="bulleted-list"><li style="list-style-type:circle">듀얼코어 쿼드코어 옥타코어</li></ul></li></ul><h2 id="3b2a6f3c-6802-4cfd-aa20-abe545a79367" class="">Q2. 동기와 비동기에 대해 예시를 들어서 설명하세요.</h2><ul id="faa9283d-49e2-40e8-b31c-389286880bf9" class="bulleted-list"><li style="list-style-type:disc">동기 : 누군가에게 일을 부탁하고 끝날때까지 잠자코 기다리는 방식<ul id="07906142-ebdb-458a-b6c5-b5e635d4bc96" class="bulleted-list"><li style="list-style-type:circle">예) 게임 퀘스트<ul id="26edf556-0eb7-4f47-96a2-dcbb326ccbd5" class="bulleted-list"><li style="list-style-type:square">이전 퀘스트를 안깨면 다음 퀘스트를 못끝냄</li></ul></li></ul></li></ul><ul id="c9a95e15-b743-468f-9df4-5fccd64828ca" class="bulleted-list"><li style="list-style-type:disc">비동기 : 끝나면 말해 해놓고 다른 일을 하는것이 비동기<ul id="1ca8acee-d99f-4ae0-82f4-667d0b0dcb01" class="bulleted-list"><li style="list-style-type:circle">끝날 때까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있음</li></ul><ul id="fb2c69b6-11ba-4169-bd28-643a6c2a0a3d" class="bulleted-list"><li style="list-style-type:circle">예) 시험지를 여러장 나눠 주는 선생님<ul id="cb6c0d80-1ec8-4932-8609-43f0a7b91496" class="bulleted-list"><li style="list-style-type:square">선생님이 시험지를 나눠주는 동안 기다리는게 아니라 시험 문제를 계속 풀고 있을 수 있음</li></ul></li></ul><ul id="43ca425c-3740-40e6-ad87-a3991e09e288" class="bulleted-list"><li style="list-style-type:circle">의뢰한 일이 끝났는지 확인 하고 싶으면 별도의 방법 이용 - 콜백 url</li></ul></li></ul><p id="67d0f61e-9175-41fc-a48d-ddace9b98730" class="">
</p><h2 id="219c2646-80e2-4cd1-9b20-320bae980982" class="">Q3. 큐는 어디서 사용하는가? 예시 및 설명</h2><ul id="cd1007df-1740-48df-94e7-113db8e3c3ad" class="bulleted-list"><li style="list-style-type:disc">잡을 큐에 넣어두고 순차적으로 잡을 진행할 때 사용</li></ul><ul id="63ca9a9a-d0a3-4cba-97a2-35c2be81d865" class="bulleted-list"><li style="list-style-type:disc">여러처리가 동시에 진행되는 경우도 사용</li></ul><ul id="7c3c8908-6e4c-417a-b81d-9afebdc876cb" class="bulleted-list"><li style="list-style-type:disc">예시)<ul id="e64c3b2c-89f2-45c8-910b-fd7e9cbde1f5" class="bulleted-list"><li style="list-style-type:circle">메시지 큐<ul id="49bd010b-7a0d-4d93-91e4-23e71a1278a4" class="bulleted-list"><li style="list-style-type:square">프로세스 또는 프로그램 인스턴스가 데이터를 서로 교환할때 사용하는 방법</li></ul><ul id="c3adf333-5a0b-4043-b185-519c20e00691" class="bulleted-list"><li style="list-style-type:square"><strong>RabbitMQ</strong></li></ul></li></ul><ul id="27984f61-9768-4357-9b0e-a1f17be3e862" class="bulleted-list"><li style="list-style-type:circle">프로세스 스케쥴링 - 라운드 로빈 등</li></ul></li></ul><p id="2cd2abbf-c8d8-4ae8-bb7e-cdd66cd8f826" class="">
</p><h2 id="86fc0ce5-2f2b-40f4-b09b-84ce6c9819a9" class="">Q4. 데이터를 일관성 있게 유지 해야하는 이유와 사용 되는 알고리즘?</h2><ul id="a6eed49a-e4a1-4281-b203-b1f153bfc06d" class="bulleted-list"><li style="list-style-type:disc">배타적 제어<ul id="96c943fd-8b12-46c6-86f9-0bc5702bd034" class="bulleted-list"><li style="list-style-type:circle">복수의 처리가 공유 자원 (CPU, 메모리, 디스크)에 동시에 액세스 하면 불일치가 발생할수 있으므로 배타적 제어로 보호해야 함</li></ul></li></ul><ul id="1f864dff-31a2-46e9-820d-26e0f2245b36" class="bulleted-list"><li style="list-style-type:disc">예시) 세마포어, 뮤텍스<ul id="2702eb4d-ec48-41fc-bfe7-18fc1fb1576a" class="bulleted-list"><li style="list-style-type:circle">세마포어(Semaphore) : 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 <strong>여러Process 혹은 Thread가 접근하는 것을 막아줌</strong>(즉, 동기화 대상이 하나 이상)</li></ul><ul id="7ed66e02-9020-46fc-bd88-7858cb7bc426" class="bulleted-list"><li style="list-style-type:circle">뮤텍스(Mutex) : 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 <strong>하나의Process 혹은 Thread가 접근하는 것을 막아줌</strong>(즉, 동기화 대상이 하나)</li></ul><p id="f9328a92-2936-45ea-a121-91693a32e0f5" class="">
</p></li></ul><h2 id="9b41cc3f-a14f-413e-90f1-38e981990a46" class="">Q5. 인덱스는 몇번 탐색하는걸 권장 할까?</h2><ul id="a3796086-1274-435e-8b13-c685311aa71a" class="bulleted-list"><li style="list-style-type:disc">두번 탐색</li></ul><ul id="3c679b49-7558-474d-83db-a2da465cab2f" class="bulleted-list"><li style="list-style-type:disc">인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문. 관련 읽기 비용이 들게 됨.</li></ul><ul id="167db6e5-b76f-47dc-8b22-5e634bdc8276" class="bulleted-list"><li style="list-style-type:disc">컬렉션이 수정되었을 때 인덱스도 수정 되어야 함. </li></ul><ul id="a24375da-b9f7-48f7-89ff-59b8cbf0c14e" class="bulleted-list"><li style="list-style-type:disc">→ B트리의 높이를 균형있게 조절 하는 비용 + 데이터를 효율적으로 조회할 수 있게 분산시키는 비용도 들기 때문</li></ul></div></article></body></html>
